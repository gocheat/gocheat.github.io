---
layout: single
title:  "클린코드(Clean Code)를 공부하며"
date: 2021-02-12
tags: [cleancode, refactoring, 마틴파울러]
categories: common

---
_해당 포스팅은 프로그래밍의 기초와 마음가짐에 대해 `클린코드` 서적을 기반으로 정리하였습니다._

클린코드(Clean Code)란 무엇인가? 
--- 

코드를 작성한 의도와 목적이 명확하여 **다른사람이 쉽게 읽을 수 있는 코드를 의미합니다 (aka. 가독성)** 비유 하자면 한권의 소설책과도 같은데 저자의 작성 의도와 스토리가 명확하며 한가지의 목적을 달성하도록 되어 있기 때문입니다.

`또한 클린코드는 개발자의 마인드셋 또는 프로페셔널을 의미한다고 생각합니다.`


클린코드의 필요 이유
--- 

개발자가 실제 업무에서 새로운 업무 혹은 기능을 추가 한다고 가정 했을때, 새로운 기능을 읽고 쓰는 비율을 따져 본다면 10:1 에 다를정도로 읽기 비율이 높기 때문에 읽기 쉬운 코드는 개발자에게 매우 중요합니다.

또한 기존 코드를 읽고 이해 해야 새로운 코드를 작성 할 수 있기 때문에 읽기 쉽게 만든다는 것은 그만큼 작성도 쉬워진다고 할 수 있습니다. **따라서 개발시간을 단축할 수 있는 가장 좋은 방법이 처음부터 읽기 쉬운 코드를 짜는 것입니다.** 


프로젝트를 처음 시작할 때는 설계나 코드 품질에 대하여 노력을 많이 기울이지만 **완료 시점이 다가올수록 시간이 부족하여 테스트나 리팩토링에 소홀해지기 쉽습니다.** 또한 오픈 이후에도 유지보수 및 신규 요구사항에 따른 변경과 결함 수정이 반복될 것입니다.

점점 코드의 크기와 복잡도는 증가하게 되고 기존 기능에 버그를 유발할까 두려워 리팩토링도 어려워지게 마련입니다. 이렇게 부채가 쌓이게 되면 소위 냄새나는 코드가 만들어지고 소프트웨어는 노후화될 수밖에 없습니다. 


![<TechnicalDebt - 클린코드 작성을 위해 개발자들이 언젠가 해결해야 되는 부채>](/assets/images/2021-02-12-clean-code/3_1_a.png)

_<TechnicalDebt - 클린코드 작성을 위해 개발자들이 언젠가 해결해야 되는 부채>_

또한 아래와 같은 이유로도 레거시 코드가 생성되곤 한다. 우선 개발 업무를 수행함에 있어 개발 생태계에서  변하는 것과 변하지 않는 것들이 있다.

- 변하는 것들: 언어에 종속적인 기능, 기술, 트렌디한 오픈소스, 프로그래밍 패러다임, 아키텍처
- 변하지 않는 것들: 주석, 네이밍등, 컴포넌트 의존성 분리 방법 등 통칭 "클린코드"

> 개발을 할때 우리는 변하는 것들에 대한 습득을 위해 많은 시간을 소비하게 됩니다. 위에 말했듯이, 새로운 언어, 새로운 오픈소스, 새로운 아키텍처 등등 우리는 _(많은 개발자들이)_ 트렌드에 시선을 빼앗겨 소프트웨어의 기본에 대해 잊게 됩니다.

_"컴퓨터가 이해하는 코드는 어느 바보나 다 짤 수 있다. 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 짠다."  - 마틴 파울러_

위의 문구에서 말했듯이 우리(개발자)는 코드의 품질에 대해서도 마땅히 책임을 져야 되고 많은 시간을 들여 클린코드 노력을 기울여야 합니다.

아래는 언어에 종속 되지 않는 몇가지 훌륭한 규칙을 소개하고자 합니다.

클린코드의 대표적 규칙
---

### 1. 의미있는 이름 

- 패키지, 변수, 함수등의 이름을 작성할때 아래와 같은 질문을 통해 의도가 분명한 이름을 사용하는 것이 중요합니다.
  ```(왜 존재해야 하는가?, 무슨 작업을 하는가?, 어떻게 사용하는가?)```

- 의미를 함축하거나 독자(코드를 읽는 사람)가 사전지식을 가지고 있다고 가정하지 말아야 합니다.
- 변수의 존재 이유, 기능, 사용법 등이 변수/함수/자료형에 드러나야 합니다. **(따로 주석이 필요하지 않을 정도로)**

  ```javascript
  //bad
  func savePoint(u []*User){ 
      for _, j := range u { 
          j.totalPoint += rewardPoint 
      } 
  }
   
  //good
  func saveRewardPointToUsers(users []*User){ 
      for _, user := range users { 
          user.totalPoint += rewardPoint
      }
  }
```

- 비슷해 보이는 명명을 주의합니다.
  
  ```
  1. Name VS NameString
  2. getActiveAccount() VS getActiveAccounts() VS getActiveAccountInfo()
  3. money VS moneyAmount
  4. message VS theMessage
  ```

- 개발자에게는 특수한 의미를 가지는 단어(```List```, ```Array```등)는 실제  저수준 자료구조를 표현한 의미가 아닌 이상 accountList와 같이 변수명에 붙이지 말자. 고수준 비즈니스 정책에 맞는 복수형 단어를 사용합니다.

  | good                        | bad       |
  |-----------------------------|-----------|
  | Points                      | PointList |
  | registrationCardsByUserName | cardMap   |

### 2. 명확하고 간결하게 주석달기

1. 주석은 필요악입니다. 코드로 의도를 표현하지 못해, 실패를 만회하기 위해 쓰는 것이며 주석은 언제나 실패를 의미합니다.
2. 주석 없이는 자신을 표현할 방법을 찾지 못해 할 수 없이 주석을 사용합니다. 주석으로 설명하려 애쓰는 대신에 그 난장판을 깨끗이 치우는 데 시간을 보내야합니다.
3. 그럼에도 주석이 필요한 경우는 코드로 의도를 표현 할 수 없을 때입니다.

  ```javascript
// 주석이 필요 없이 코드에서 의도를 표현
if (employee.isEligibleForFullBenefits())
 
// 코드로 의도를 표현 할수 없는 경우 아래와 같이 주석으로 표현
// 직원에게 복지 혜택을 받을 자격이 있는지 검사한다.
if ((emplotee.flags & HOURLY_FLAG) && (employee.age > 65))
  ```

### 3. 함수

- ```반복하지 마라``` - 동일한 일을 하는 중복코드 발생 시 반드시 함수로 만들어 줘야합니다. ( 대개 시간이라는 핑계로 지키지 못하는 것 중 하나 )
- ```함수를 만들때 최대한 작게 만들어라``` - 함수는 프로그램의 기본 단위입니다. 이러한 함수가 작게 만들어질수록 추상화 및 역할 분리가 된다는것을 의미합니다.  
- ```한가지만 해라``` - 함수는 한가지 일만 해야합니다. 이로 인한 이점은 유지보수 시 강력한 재사용성 보장으로 인해 리소스가 줄어듭니다.
- ```플래그 인수를 사용하지 마라``` - 플래그 인수를 사용한다는 것은 함수 내에서 여러가지 행위를 한다는 것을 의미합니다. 앞단계에서 추상화를 통해 행위에 대한 위임을 해야합니다.
- ```함수의 인자를 최소한으로 해라``` -  함수의 인자가 많아질수록 해당 함수를 사용하는 측에서의 이해하기 힘들어지고 복잡도가 증가합니다. ( 규칙을 정해 3개 이상일 경우는 하나의 의미있는 자료구조로 선언하여 인자로 사용합니다.)
- ```함수의 인자로 NULL 을 허용하거나 NULL 을 리턴시키지 마라``` (```golang은 nil```) - Null이라는 또다른 예외케이스로 인하여 사용하는 측에서 함수 내에서 불필요한 처리 로직이 들어갑니다.


### 4.객체와 자료구조

- **_객체_**는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개합니다.
- **_자료 구조_**는 자료를 그대로 공개하며 별다른 함수는 제공하지 않습니다.
> (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.

  반대쪽도 참입니다.
> 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.

다시 말해, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽습니다.


**< 절차적인 도형 >**
```javascript
type Point struct {
   X float32
   Y float32
}
 
type Square struct {
   topLeft Point
   side    float32
}
 
type Circle struct {
   center Point
   radius float32
}
 
const PI = 3.141592653589793
 
type Geometry struct{}
 
func (g *Geometry) area(object interface{}) (float32, error) {
   switch object.(type) {
   case Square:
      square := object.(Square)
      return square.side * square.side, nil
   case Circle:
      circle := object.(Circle)
      return circle.radius * PI, nil
   }
   return 0, errors.New("error")
}
```


**< 다형(객체지향)적 도형 >**
```javascript
type Shape interface {
   area() float32
}
 
type Point struct {
   X float32
   Y float32
}
 
type Square struct {
   topLeft Point
   side float32
}
 
func(s *Square) area() float32 {
   return s.side * s.side
}
 
const PI = 3.141592653589793
 
type Circle struct {
   center Point
   radius float32
}
 
func(c *Circle) area() float32 {
   return c.radius * PI
}
```
복잡한 시스템을 짜다 보면 새로운 함수가 필요할 경우거나, 새로운 자료 타입이 필요한 경우가 생깁니다. 이때 상황에 맞게 클래스 & 객체 지향 기법을 사용하거나, 절차적인 코드와 자료 구조를 적절하게 사용하는 것이 좋습니다.

분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 알고있습니다. 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있습니다.

### 5.단위테스트 규칙

(`TDD의 세가지 규칙`) TDD가 실제 코드를 짜기 전에 단위 테스트부터 짜라고 요구한다는 사실을 모르는 사람은 없을것입니다. 하지만 이 규칙은 빙산의 일각에 불과합니다. 

다음 세 가지 법칙을 살펴봅시다.

- `첫째 법칙`: 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
- `둘째 법칙`: 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
- `셋째 법칙`: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

위 세 가지 규칙을 따르면 개발과 테스트가 대략 30초 주기로 묶입니다. 
테스트 코드와 실제 코드가 함께 나올뿐더러 테스트 코드가 실제 코드보다 불과 몇 초 전에 나옵니다.

이렇게 일하면 매일 수십 개, 매달 수백 개, 매년 수천 개에 달하는 테스트 케이스가 나옵니다. 
실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나옵니다. 

하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 합니다.

때문에 테스트 코드 작성 시에도 규칙 또한 매우 중요한 요소입니다.

---

**깨끗한 테스트 코드**

| 규칙                        | 설명       |
|-----------------------------|-----------|
| 빠르게(Fast)                      | 테스트는 빨라야 한다. 테스트는 빨리 돌아야 한다는 말이다. 테스트가 느리면 자주 돌릴 엄두를 못 낸다. 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다. 코드를 마음껏 정리하지도 못한다. 결국 코드 품질이 망가지기 시작한다. |
| 독립적으로(Independent) | 각 테스트를 서로 의존하면 안 된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다.   |
| 반복가능하게(Repeatable) | 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 버스를 타고 집으로 가는 길에 사용하는 노트북 환경(네트워크가 연결되지 않은)에서도 실행할 수 있어야 한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다. 게다가 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황에 직면한다. |
| 자가검증하는(Self-Validating)| 테스트는 bool값으로 결과를 내야 한다. 성공 아니면 실패다. 통과 여부를 알리고 로그 파일을 읽게 만들어서는 안 된다. 통과 여부를 보려고 텍스트 파일 두 개를 수작업으로 비교하게 만들어서도 안 된다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다. |
| 적시에(Timely) | 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다. 어떤 실제 코드는 테스트하기 너무 어렵다고 판명날지 모른다. 테스트가 불가능하도록 실제 코드를 설계할지도 모른다. |	
	
- 테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요합니다. 어쩌면 실제 코드보다 더 중요할지도 모르겠습니다.

- 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문입니다. 테스트 코드가 방치되어 망가지면 실제 코드도 망가집니다. 테스트 코드를 깨끗하게 유지해야 합니다.


### 6.점진적인 개선 (리팩토링)

- 그저 돌아가는 코드만으로는 부족합니다. 돌아가는 코드가 심하게 망가지는 사례는 흔하며 단순히 돌아가는 코드에 만족하는 프로그래머는 전문가 정신이 부족한 코더일 뿐입니다.
- 나쁜 코드보다 더 오랫동안 더 심각하게 개발 프로젝트에 악영향을 미치는 요인도 없습니다.
- 나쁜 일정은 다시 짜면 됩니다. 나쁜 요구사항은 다시 정의하면 됩니다. 나쁜 팀 역학은 복구하면 됩니다. 하지만 나쁜 코드는 썩어 문드러집니다. 점점 무게가 늘어나 팀의 발목을 잡는다. 이로 인해 프로젝트 개발 속도가 점점 느려지다 못해 기어가는 팀도 많이 봤습니다. 
- 오래된 의존성을 찾아내 깨려면 상당한 시간과 인내심이 필요합니다. 반면 처음부터 코드를 깨끗하게 유지하기란 상대적으로 쉽다. 아침에 엉망으로 만든 코드를 오후에 정리하기는 어렵지 않습니다. 더욱이 5분 전에 엉망으로 만든 코드는 지금 당장 정리하기 아주 쉽습니다.

그러므로 코드는 언제나 최대한 깔끔하고 단순하게 정리해야합니다. 절대로 썩어가게 방치하면 안 됩니다.

참고문서
--- 
- 마틴 파울러의 `클린 아키텍처` 책을 기반으로 작성하였습니다.